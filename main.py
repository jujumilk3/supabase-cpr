import os
import socket
import subprocess
import psycopg2
from psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT
from urllib.parse import urlparse


def parse_connection_string(db_url):
    """Parse connection string and return components."""
    try:
        parsed = urlparse(db_url)
        return {
            'dbname': parsed.path.lstrip('/') or 'postgres',
            'user': parsed.username,
            'password': parsed.password,
            'host': parsed.hostname,
            'port': parsed.port or 5432
        }
    except Exception:
        return None


def resolve_ipv4_with_dig(hostname):
    """Resolve hostname to IPv4 using dig command."""
    try:
        result = subprocess.run(
            ['dig', '+short', 'A', hostname],
            capture_output=True,
            text=True,
            timeout=5
        )
        if result.returncode == 0 and result.stdout.strip():
            ipv4_addresses = [line.strip() for line in result.stdout.strip().split('\n') if line.strip()]
            if ipv4_addresses:
                return ipv4_addresses[0]
    except Exception:
        pass
    return None


def resolve_ipv4(hostname):
    """Resolve hostname to IPv4 address only."""
    # Try dig command first (most reliable for getting A records)
    ipv4 = resolve_ipv4_with_dig(hostname)
    if ipv4:
        return ipv4

    # Fallback to socket.getaddrinfo
    try:
        # Force IPv4 resolution using AF_INET
        addr_info = socket.getaddrinfo(
            hostname,
            None,
            socket.AF_INET,  # Force IPv4
            socket.SOCK_STREAM,
            socket.IPPROTO_TCP
        )
        if addr_info:
            return addr_info[0][4][0]
    except Exception:
        pass

    return hostname


def get_supabase_databases():
    databases = {}
    for key, value in os.environ.items():
        if key.startswith("SUPABASE_DATABASE_"):
            databases[key] = value
    return databases


def create_table_if_not_exists(conn):
    try:
        cursor = conn.cursor()

        create_table_query = """
        CREATE TABLE IF NOT EXISTS public.cpr_table (
            id int8 GENERATED BY DEFAULT AS IDENTITY(
                INCREMENT BY 1
                MINVALUE 1
                MAXVALUE 9223372036854775807
                START 1
                CACHE 1
                NO CYCLE
            ) NOT NULL,
            created_at timestamptz DEFAULT now() NOT NULL,
            CONSTRAINT cpr_table_pkey PRIMARY KEY (id)
        );
        """

        cursor.execute(create_table_query)
        conn.commit()
        cursor.close()
        print("  ✓ Table checked/created successfully")
        return True
    except Exception:
        print("  ✗ Error creating table")
        return False


def insert_record(conn):
    try:
        cursor = conn.cursor()

        # Get count and last record before insert
        cursor.execute("SELECT COUNT(*) FROM public.cpr_table;")
        count_before = cursor.fetchone()[0]

        # Get last record info (most recent before insert)
        cursor.execute(
            "SELECT id, created_at FROM public.cpr_table ORDER BY id DESC LIMIT 1;"
        )
        last_record = cursor.fetchone()

        # Insert new record
        insert_query = "INSERT INTO public.cpr_table (created_at) VALUES (NOW()) RETURNING id, created_at;"
        cursor.execute(insert_query)
        new_record = cursor.fetchone()
        conn.commit()

        # Get count after insert
        cursor.execute("SELECT COUNT(*) FROM public.cpr_table;")
        count_after = cursor.fetchone()[0]

        cursor.close()

        # Print summary
        print(f"  ✓ Record inserted successfully ({count_before} -> {count_after})")
        if last_record:
            print(f"    Previous: [id={last_record[0]}] {last_record[1]}")
        else:
            print(f"    Previous: (none - first record)")
        print(f"    Current:  [id={new_record[0]}] {new_record[1]}")

        return True
    except Exception:
        print("  ✗ Error inserting record")
        return False


def process_database(db_name, db_url):
    print(f"\nProcessing database: {db_name}")

    try:
        # Parse connection string
        conn_params = parse_connection_string(db_url)
        if not conn_params:
            print("  ✗ Invalid connection string")
            return False

        # Resolve hostname to IPv4
        hostname = conn_params['host']
        ipv4_addr = resolve_ipv4(hostname)

        # Build connection parameters
        conn_kwargs = {
            'dbname': conn_params['dbname'],
            'user': conn_params['user'],
            'password': conn_params['password'],
            'port': conn_params['port'],
            'connect_timeout': 10
        }

        # Use hostaddr only if we successfully resolved to an IP
        # hostaddr forces IPv4 and bypasses DNS issues
        if ipv4_addr != hostname and '.' in ipv4_addr and not ipv4_addr.count('.') != 3:
            conn_kwargs['host'] = hostname
            conn_kwargs['hostaddr'] = ipv4_addr
        else:
            conn_kwargs['host'] = hostname

        conn = psycopg2.connect(**conn_kwargs)
        conn.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)

        if create_table_if_not_exists(conn):
            insert_record(conn)

        conn.close()
        print("  ✓ Database processed successfully")
        return True
    except Exception:
        print("  ✗ Connection failed")
        return False


def main():
    print("=" * 50)
    print("Supabase CPR - Database Keep-Alive Service")
    print("=" * 50)

    databases = get_supabase_databases()

    if not databases:
        print("\n⚠ No database configurations found!")
        print("Please set environment variables starting with 'SUPABASE_DATABASE_'")
        print("Example: SUPABASE_DATABASE_URL_1=postgresql://...")
        return

    print(f"\nFound {len(databases)} database(s) to process:")
    for db_name in databases.keys():
        print(f"  - {db_name}")

    success_count = 0
    for db_name, db_url in databases.items():
        if process_database(db_name, db_url):
            success_count += 1

    print("\n" + "=" * 50)
    print(f"Summary: {success_count}/{len(databases)} database(s) processed successfully")
    print("=" * 50)


if __name__ == "__main__":
    main()
